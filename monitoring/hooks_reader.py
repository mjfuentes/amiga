"""
Reader for Claude Code hook logs
Parses session logs generated by hooks
"""

import json
import logging
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from core.exceptions import AMIGAError

logger = logging.getLogger(__name__)


@dataclass
class HookSessionSummary:
    """Summary of hook data for a session"""

    session_id: str
    total_tools: int
    tools_by_type: dict[str, int]
    blocked_operations: int
    tools_with_errors: int
    timestamps: list[str]


class HooksReader:
    """Reads and aggregates Claude Code hook logs"""

    def __init__(self, sessions_dir: str = "logs/sessions", additional_dirs: list[str] | None = None) -> None:
        self.sessions_dir = Path(sessions_dir)
        self.additional_dirs = [Path(d) for d in (additional_dirs or [])]
        all_dirs = [self.sessions_dir] + self.additional_dirs
        logger.info(f"HooksReader initialized for {', '.join(str(d) for d in all_dirs)}")

    def get_all_sessions(self) -> list[str]:
        """Get list of all session IDs from all configured directories"""
        session_ids: set[str] = set()

        # Check primary directory
        if self.sessions_dir.exists():
            session_ids.update(d.name for d in self.sessions_dir.iterdir() if d.is_dir())

        # Check additional directories
        for sessions_dir in self.additional_dirs:
            if sessions_dir.exists():
                session_ids.update(d.name for d in sessions_dir.iterdir() if d.is_dir())

        return list(session_ids)

    def _find_session_dir(self, session_id: str) -> Path | None:
        """Find the directory containing a specific session"""
        # Check primary directory first
        session_dir = self.sessions_dir / session_id
        if session_dir.exists():
            return session_dir

        # Check additional directories
        for sessions_dir in self.additional_dirs:
            session_dir = sessions_dir / session_id
            if session_dir.exists():
                return session_dir

        return None

    def read_session_summary(self, session_id: str) -> HookSessionSummary | None:
        """Read summary for a specific session"""
        session_dir = self._find_session_dir(session_id)
        if not session_dir:
            return None

        summary_file = session_dir / "summary.json"
        if not summary_file.exists():
            return None

        try:
            with open(summary_file) as f:
                data = json.load(f)

            return HookSessionSummary(
                session_id=data.get("task_id", session_id),
                total_tools=data.get("total_tools_used", 0),
                tools_by_type=data.get("tools_by_type", {}),
                blocked_operations=data.get("blocked_operations", 0),
                tools_with_errors=data.get("tools_with_errors", 0),
                timestamps=[],
            )
        except Exception as e:
            logger.error(f"Error reading session summary {session_id}: {e}", exc_info=True)
            return None

    def read_session_pre_tools(self, session_id: str) -> list[dict]:
        """Read pre-tool logs for a session"""
        session_dir = self._find_session_dir(session_id)
        if not session_dir:
            return []

        pre_file = session_dir / "pre_tool_use.jsonl"
        if not pre_file.exists():
            return []

        try:
            tools = []
            with open(pre_file) as f:
                for line in f:
                    if line.strip():
                        tools.append(json.loads(line))
            return tools
        except Exception as e:
            logger.error(f"Error reading pre-tool logs {session_id}: {e}", exc_info=True)
            return []

    def read_session_post_tools(self, session_id: str) -> list[dict]:
        """Read post-tool logs for a session"""
        session_dir = self._find_session_dir(session_id)
        if not session_dir:
            return []

        post_file = session_dir / "post_tool_use.jsonl"
        if not post_file.exists():
            return []

        try:
            tools = []
            with open(post_file) as f:
                for line in f:
                    if line.strip():
                        tools.append(json.loads(line))
            return tools
        except Exception as e:
            logger.error(f"Error reading post-tool logs {session_id}: {e}", exc_info=True)
            return []

    def get_aggregate_statistics(self, hours: int = 24) -> dict[str, Any]:
        """Get aggregate statistics from all sessions"""
        cutoff = datetime.now().timestamp() - (hours * 3600)

        total_sessions = 0
        total_tools = 0
        tools_by_type: dict[str, int] = defaultdict(int)
        total_blocked = 0
        total_errors = 0
        recent_sessions = []

        for session_id in self.get_all_sessions():
            # Check if session is within time window (using directory mtime as proxy)
            session_dir = self._find_session_dir(session_id)
            if not session_dir or session_dir.stat().st_mtime < cutoff:
                continue

            # Read post_tools once for both summary and timestamp
            post_tools = self.read_session_post_tools(session_id)
            if not post_tools:
                continue

            # Try to read summary, if not available compute from logs
            summary = self.read_session_summary(session_id)
            if not summary:
                # Compute summary from log files
                pre_tools = self.read_session_pre_tools(session_id)

                # Count tools by type
                session_tools_by_type: dict[str, int] = defaultdict(int)
                for tool in post_tools:
                    tool_name = tool.get("tool", "unknown")
                    session_tools_by_type[tool_name] += 1

                # Count blocked and errors
                session_blocked = len([t for t in pre_tools if t.get("status") == "blocked"])
                session_errors = len([t for t in post_tools if t.get("has_error", False)])

                summary = HookSessionSummary(
                    session_id=session_id,
                    total_tools=len(post_tools),
                    tools_by_type=dict(session_tools_by_type),
                    blocked_operations=session_blocked,
                    tools_with_errors=session_errors,
                    timestamps=[],
                )

            total_sessions += 1
            total_tools += summary.total_tools
            total_blocked += summary.blocked_operations
            total_errors += summary.tools_with_errors

            for tool in summary.tools_by_type:
                count = summary.tools_by_type[tool]
                tools_by_type[tool] += count

            # Get last activity timestamp from post_tools (already loaded above)
            last_activity: str | None = None
            timestamps = [t.get("timestamp") for t in post_tools if t.get("timestamp")]
            if timestamps:
                # Filter out None values and cast to str
                valid_timestamps = [ts for ts in timestamps if ts is not None]
                if valid_timestamps:
                    last_activity = max(valid_timestamps)

            recent_sessions.append(
                {
                    "session_id": session_id,
                    "total_tools": summary.total_tools,
                    "blocked": summary.blocked_operations,
                    "errors": summary.tools_with_errors,
                    "last_activity": last_activity,
                }
            )

        # Sort by last_activity (most recent first), fallback to total_tools if no timestamp
        sorted_sessions = sorted(
            recent_sessions, key=lambda x: (x["last_activity"] or "", x["total_tools"]), reverse=True
        )[:20]

        return {
            "time_window_hours": hours,
            "total_sessions": total_sessions,
            "total_tool_calls": total_tools,
            "total_blocked_operations": total_blocked,
            "total_errors": total_errors,
            "tools_by_type": dict(tools_by_type),
            "recent_sessions": sorted_sessions,
        }

    def get_session_timeline(self, session_id: str) -> list[dict]:
        """Get complete timeline of events for a session"""
        pre_tools = self.read_session_pre_tools(session_id)
        post_tools = self.read_session_post_tools(session_id)

        # Combine and sort by timestamp
        events = []

        for tool in pre_tools:
            events.append(
                {
                    "timestamp": tool.get("timestamp"),
                    "type": "pre_tool",
                    "tool": tool.get("tool"),
                    "status": tool.get("status"),
                    "parameters": tool.get("parameters", {}),
                }
            )

        for tool in post_tools:
            events.append(
                {
                    "timestamp": tool.get("timestamp"),
                    "type": "post_tool",
                    "tool": tool.get("tool"),
                    "output_length": tool.get("output_length"),
                    "has_error": tool.get("has_error", False),
                }
            )

        # Sort by timestamp (handle None timestamps)
        events.sort(key=lambda e: e.get("timestamp") or "")

        return events
