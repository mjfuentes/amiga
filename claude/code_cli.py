"""
Interactive Claude Code session handler
Phase 3-4: Full tool access for code operations
Enhanced with workflow enforcement for testing and commits
Enhanced with tool usage tracking via hooks
Enhanced with security: prompt injection prevention and input sanitization
"""

import asyncio
import logging
import os
import subprocess
import time
from collections.abc import Callable
from pathlib import Path

from claude.api_client import detect_prompt_injection, sanitize_xml_content
from tasks.enforcer import WorkflowEnforcer
from tasks.tracker import ToolUsageTracker

from core.exceptions import AMIGAError

logger = logging.getLogger(__name__)


class PromptBuilder:
    """
    Reusable prompt engineering components for Claude interactions
    Optimized with XML structure for clarity and token efficiency
    """

    @staticmethod
    def build_bot_context(bot_repo_path: str) -> str:
        """Build context about the bot's codebase with XML structure"""
        # Security: Sanitize bot repo path using centralized utility
        safe_path = sanitize_xml_content(bot_repo_path)

        return f"""<bot_context>
You are a Telegram bot powered by Claude Code. When users say "you", "your code", or "the bot", they mean YOUR codebase.

<structure>
Location: {safe_path}
telegram_bot/main.py - Entry point, handlers, routing
telegram_bot/session.py - Session & history mgmt
telegram_bot/tasks.py - Background task tracking
telegram_bot/claude_interactive.py - YOU are invoked from here
data/ - Persistent storage (sessions, tasks)
logs/ - Application logs
</structure>

Use NLU to determine: user's own code vs. modifying bot code.
</bot_context>"""

    @staticmethod
    def build_task_prompt(
        task_description: str,
        workspace: str | Path,
        bot_context: str = "",
        workflow_context: str = "",
    ) -> str:
        """
        Build complete task execution prompt with XML structure
        Optimized for token efficiency and clarity
        Security: Sanitizes all user inputs before inclusion using centralized utilities
        """
        # Security: Detect prompt injection using centralized utility
        is_malicious, injection_reason = detect_prompt_injection(task_description)
        if is_malicious:
            logger.error(f"Prompt injection detected: {injection_reason} in task: {task_description[:100]}", exc_info=True)
            # Return safe error message - don't expose validation details
            task_description = f"Invalid task description provided (security check failed)"

        # Security: Sanitize using centralized utility
        safe_task = sanitize_xml_content(task_description)
        safe_workspace = sanitize_xml_content(str(workspace))

        parts = []

        # Add bot context (already XML-formatted and sanitized)
        if bot_context:
            parts.append(bot_context)
            parts.append("")

        # User request (XML tag) - sanitized
        parts.append(f"<request>{safe_task}</request>")
        parts.append("")

        # Environment info (XML structure) - sanitized
        parts.append("<environment>")
        parts.append(f"working_directory: {safe_workspace}")
        parts.append("tools_available: Read, Write, Edit, Glob, Grep, Bash")
        parts.append("</environment>")
        parts.append("")

        # Workflow context if provided (trusted internal content)
        if workflow_context:
            parts.append(workflow_context)
            parts.append("")

        # Completion instructions (XML tag for clarity)
        parts.append("<instructions>")
        parts.append("Complete the task and provide a concise summary.")
        parts.append("</instructions>")

        return "\n".join(parts)


class ClaudeInteractiveSession:
    """
    Interactive Claude Code session with full tool access
    Unlike non-interactive mode, this can use Read, Write, Edit, Bash, etc.
    """

    def __init__(
        self,
        workspace: Path,
        model: str = "sonnet",
        enforce_workflow: bool = True,
        usage_tracker: ToolUsageTracker | None = None,
    ):
        self.workspace = workspace
        self.model = model
        self.process: subprocess.Popen | None = None
        self.task_id: str | None = None
        self.enforce_workflow = enforce_workflow
        self.workflow_enforcer = WorkflowEnforcer(workspace) if enforce_workflow else None
        self.usage_tracker = usage_tracker


    async def _extract_claude_session_id(self) -> str | None:
        """
        Extract actual session ID that Claude Code generated by checking session logs directory.

        Claude Code ignores --session-id flag and generates its own UUID.
        It creates a logs/sessions/{uuid}/ directory immediately on start.

        Returns:
            Claude's actual session UUID, or None if extraction fails
        """
        import re

        if not self.process:
            return None

        try:
            # Wait for Claude to create session directory
            # Claude creates logs/sessions/{session_uuid}/ immediately on start
            sessions_dir = Path("logs/sessions")

            # Record current time to find directories created after process start
            start_time = time.time()

            # Wait up to 2 seconds for session directory to appear
            for _ in range(20):  # 20 * 0.1s = 2s timeout
                await asyncio.sleep(0.1)

                if not sessions_dir.exists():
                    continue

                # Find newest directory created after process start
                uuid_pattern = re.compile(r"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")

                for entry in sorted(sessions_dir.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True):
                    if not entry.is_dir():
                        continue

                    # Check if directory name is a UUID
                    if uuid_pattern.match(entry.name):
                        # Check if created after process start (within last 5 seconds)
                        dir_age = start_time - entry.stat().st_mtime
                        if -1 < dir_age < 5:  # Allow slight time skew
                            session_uuid = entry.name
                            logger.info(f"Extracted Claude session UUID from logs directory: {session_uuid}")
                            return session_uuid

            logger.warning("Could not find Claude session directory in logs/sessions/")
            return None

        except Exception as e:
            logger.error(f"Error extracting Claude session UUID: {e}", exc_info=True)
            return None

    async def start(self, task_id: str, prompt: str | None = None):
        """Start non-interactive Claude session with -p flag

        Args:
            task_id: Task identifier for tracking
            prompt: Optional prompt to pass as argument. If None, will wait for send_message call.
        """
        self.task_id = task_id
        self.prompt = prompt

        try:
            # Defensive check: warn if usage_tracker is missing
            if not self.usage_tracker:
                logger.warning(
                    f"Task {task_id}: usage_tracker is None - session_uuid will NOT be tracked in database! "
                    "This will break tool usage correlation in dashboard."
                )

            # Record agent status change
            if self.usage_tracker:
                self.usage_tracker.record_status_change(task_id, "started", "Starting Claude interactive session")

            # Start Claude in interactive mode with auto-approval for background tasks
            # Note: Claude Code IGNORES --session-id flag and generates its own UUID
            # We'll extract the actual UUID after process starts
            import uuid

            # Create deterministic UUID for our reference (not used by Claude)
            task_uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, f"agentlab.task.{task_id}"))

            cmd = [
                "claude",
                "-p",  # Non-interactive mode: print response and exit
                "--model",
                self.model,
                "--permission-mode",
                "bypassPermissions",  # Auto-approve file operations
                "--session-id",
                task_uuid,
            ]

            # Pass prompt directly - no extra wrapping needed
            task_description = self.prompt
            logger.info(f"Task description: {task_description[:100]}...")

            # Workflow slash commands need specific tools:
            # - Task: Invoke specialized agents (code_agent, frontend_agent, etc.)
            # - TodoWrite: Track progress
            # - Read/Glob/Grep/Bash: Analyze codebase before routing to agents
            # - Write/Edit: Create simple files if needed (reports, logs)
            # Note: Specialized agents invoked via Task tool get their own tool lists from their .md configs
            # Note: MCP tools (like Playwright) are available if configured in ~/.claude.json
            cmd.extend(["--allowed-tools", "Task,TodoWrite,Read,Write,Edit,Glob,Grep,Bash"])

            logger.info(f"Starting Claude non-interactive session for task {task_id}")
            logger.info(f"Command: {' '.join(cmd)}")
            logger.info(f"Workspace: {self.workspace}")

            # Set PROJECT_ROOT so hooks can find database in main repo (not worktree)
            # Worktrees have .git file pointing to main repo, but data/ is in main repo only
            env = os.environ.copy()

            # CRITICAL: Set TASK_ID environment variable for git-worktree agent
            # This ensures consistent task numbering between database and worktree directories
            env["TASK_ID"] = task_id
            logger.info(f"Task {task_id}: Set TASK_ID environment variable for worktree naming consistency")

            if self.workspace.name != "agentlab":
                # In worktree - find main repo by following .git symlink
                git_file = self.workspace / ".git"
                if git_file.exists() and git_file.is_file():
                    # Parse .git file to get main repo path
                    git_content = git_file.read_text().strip()
                    if git_content.startswith("gitdir:"):
                        # gitdir: /path/to/main/repo/.git/worktrees/task_id
                        gitdir_path = Path(git_content.split("gitdir:")[1].strip())
                        # Go up 3 levels: .git/worktrees/task_id -> .git/worktrees -> .git -> repo
                        main_repo = gitdir_path.parent.parent.parent
                        env["PROJECT_ROOT"] = str(main_repo)
            else:
                # In main repo
                env["PROJECT_ROOT"] = str(self.workspace)

            # Add task description as positional argument
            # Use -- separator to prevent flags from consuming the prompt
            if task_description:
                cmd.append("--")
                cmd.append(task_description)
                logger.info(f"Added task description as argument: {task_description[:100]}...")

            # Create subprocess with stdin=DEVNULL (no interactive input needed)
            self.process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.DEVNULL,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(self.workspace),
                env=env,
            )

            logger.info(f"Non-interactive session started (PID: {self.process.pid})")

            # CRITICAL FIX: Extract Claude's actual session UUID
            # Claude ignores our --session-id flag and generates its own UUID
            # We must capture this UUID to correlate tool_usage records from hooks
            actual_session_uuid = await self._extract_claude_session_id()

            if actual_session_uuid:
                logger.info(f"Task {task_id}: Using Claude's actual session_uuid={actual_session_uuid}")
                session_uuid_to_use = actual_session_uuid
            else:
                logger.warning(f"Task {task_id}: Failed to extract Claude's session UUID, using fallback={task_uuid}")
                session_uuid_to_use = task_uuid

            # Record successful start with PID and actual session UUID
            if self.usage_tracker:
                self.usage_tracker.record_status_change(
                    task_id,
                    "started",
                    f"Session started with PID {self.process.pid}",
                    metadata={
                        "pid": self.process.pid,
                        "workspace": str(self.workspace),
                        "session_uuid": session_uuid_to_use,
                        "requested_uuid": task_uuid,
                        "actual_uuid": actual_session_uuid,
                    },
                )

                # Update task with ACTUAL session UUID for tool usage correlation
                await self.usage_tracker.db.update_task(
                    task_id=task_id, session_uuid=session_uuid_to_use, pid=self.process.pid
                )
                logger.info(
                    f"Task {task_id}: Successfully set session_uuid={session_uuid_to_use} for tool usage correlation"
                )

            # Log workspace path to terminal for easy reference
            logger.info(f"Task {task_id}: Working directory: {self.workspace}")

            return True

        except Exception as e:
            logger.error(f"Failed to start interactive session: {e}", exc_info=True)

            # Record failure
            if self.usage_tracker:
                self.usage_tracker.record_status_change(task_id, "failed", f"Failed to start session: {str(e)}")

            return False

    async def wait_for_completion(
        self,
        progress_callback: Callable[[str, int], None] | None = None,
    ) -> str | None:
        """Wait for non-interactive process to complete and collect output

        Args:
            progress_callback: Optional callback for progress updates. Called with (status_message, elapsed_seconds)

        Returns:
            Combined stdout output from the process
        """
        if not self.process:
            logger.error("No active session", exc_info=True)
            return None

        try:
            logger.debug(f"Waiting for non-interactive execution to complete (task {self.task_id})")

            # Stream output
            start_time = time.time()
            stdout_chunks = []
            stderr_chunks = []
            last_callback_time = start_time

            async def read_stream(stream, chunks, stream_name):
                """Read from stream line by line"""
                nonlocal last_callback_time
                while True:
                    try:
                        line = await stream.readline()
                        if not line:
                            break
                        decoded = line.decode()
                        chunks.append(decoded)
                        logger.debug(f"Claude {stream_name} (task {self.task_id}): {decoded.rstrip()}")

                        # Call progress callback every 5 seconds with output line count
                        if progress_callback and stream_name == "stdout":
                            current_time = time.time()
                            if current_time - last_callback_time >= 5:
                                elapsed = int(current_time - start_time)
                                output_lines = len(stdout_chunks)
                                progress_callback(f"Processing... {output_lines} output lines", elapsed)
                                last_callback_time = current_time
                    except Exception as e:
                        logger.error(f"Error reading {stream_name}: {e}", exc_info=True)
                        break

            # Start reading both streams
            stdout_task = asyncio.create_task(read_stream(self.process.stdout, stdout_chunks, "stdout"))
            stderr_task = asyncio.create_task(read_stream(self.process.stderr, stderr_chunks, "stderr"))

            # Wait for both streams to finish
            await asyncio.gather(stdout_task, stderr_task)

            # Wait for process to exit
            await self.process.wait()

            # Combine output
            response = "".join(stdout_chunks).strip()
            stderr_output = "".join(stderr_chunks).strip()

            elapsed = int(time.time() - start_time)

            if stderr_output:
                logger.debug(f"Claude stderr (task {self.task_id}): {stderr_output}")

            if response:
                logger.info(f"Received response from Claude (task {self.task_id}): {len(response)} chars in {elapsed}s")
                if progress_callback:
                    progress_callback(f"Completed in {elapsed}s", elapsed)
                return response
            else:
                logger.warning(f"Empty response from Claude (task {self.task_id}) after {elapsed}s")
                if progress_callback:
                    progress_callback(f"Warning: Empty response after {elapsed}s", elapsed)
                return None

        except Exception as e:
            logger.error(f"Error sending message (task {self.task_id}): {e}", exc_info=True)
            await self.terminate()
            return None

    async def send_message(self, message: str) -> str | None:
        """Send message to Claude and get response (backward compatible version)

        Note: With -p flag, this method is deprecated. Use wait_for_completion() instead.
        If process not started with prompt, will restart with message as prompt.
        """
        # If process not started with prompt yet, restart with this message
        if not self.prompt:
            logger.info(f"Restarting session with prompt for task {self.task_id}")
            await self.terminate()
            if not await self.start(self.task_id, prompt=message):
                return None

        return await self.wait_for_completion(progress_callback=None)

    async def terminate(self):
        """Terminate the session"""
        if self.process:
            try:
                # Check if process is still running
                if self.process.returncode is None:
                    self.process.terminate()
                    await self.process.wait()
                    logger.info(f"Session terminated for task {self.task_id}")
                else:
                    logger.info(
                        f"Session already exited for task {self.task_id} (returncode: {self.process.returncode})"
                    )
            except ProcessLookupError:
                # Process already terminated
                logger.debug(f"Session process already terminated for task {self.task_id}")
            except Exception as e:
                error_msg = str(e) if str(e) else type(e).__name__
                logger.error(f"Error terminating session: {error_msg}", exc_info=True)

            self.process = None

    async def execute_task(self, task_description: str, bot_repo_path: str | None = None) -> tuple[bool, str]:
        """
        Execute a coding task by delegating to orchestrator
        Returns: (success, result_message)
        """
        try:
            # Build simple task description
            task_parts = []

            if bot_repo_path:
                task_parts.append(f"Bot codebase: {bot_repo_path}")
            task_parts.append(task_description)

            simple_task = "\n\n".join(task_parts)

            logger.info(f"Task {self.task_id}: {simple_task[:100]}...")

            # Start session with task description
            if not await self.start(self.task_id or "unknown", prompt=simple_task):
                return False, "Failed to start Claude session"

            # Wait for completion
            response = await self.wait_for_completion()

            # Cleanup
            await self.terminate()

            if not response:
                return False, "No response from Claude"

            # Workflow handles its own enforcement, commits, and QA
            # No need for separate workflow_enforcer checks

            return True, response

        except Exception as e:
            logger.error(f"Task execution error: {e}", exc_info=True)
            await self.terminate()
            return False, f"Error: {str(e)}"


class ClaudeSessionPool:
    """
    Pool of Claude sessions for concurrent task execution

    Note: Worktree management is handled by git-worktree agent within workflows,
    not by the session pool. This allows workflows to explicitly control when
    and how worktrees are created/managed.
    """

    def __init__(
        self,
        max_concurrent: int = 3,
        enforce_workflow: bool = True,
        usage_tracker: ToolUsageTracker | None = None,
    ):
        self.max_concurrent = max_concurrent
        self.enforce_workflow = enforce_workflow
        self.usage_tracker = usage_tracker
        self.active_sessions: dict[str, ClaudeInteractiveSession] = {}

    async def execute_task(
        self,
        task_id: str,
        description: str,
        workspace: Path,
        bot_repo_path: str | None = None,
        model: str = "sonnet",
        context: str | None = None,
        pid_callback: Callable[[int], None] | None = None,
        progress_callback: Callable[[str, int], None] | None = None,
    ) -> tuple[bool, str, int | None, str | None]:
        """Execute a task using session pool - ALWAYS invokes via workflow slash commands

        Args:
            context: Optional context summary from Claude API (user's original message, conversation context)
            pid_callback: Optional callback function called with PID when process starts
                         Format: pid_callback(pid: int)
            progress_callback: Optional callback for progress updates
                              Format: progress_callback(status_message: str, elapsed_seconds: int)

        Returns:
            (success, result, pid, workflow) - pid is the Claude process ID if available, workflow is the workflow name used
        """

        # Wait if at capacity
        while len(self.active_sessions) >= self.max_concurrent:
            await asyncio.sleep(1)

        # Workflows orchestrate directly - no workflow enforcement needed (they ARE the workflow)
        # Workflow enforcement is for specialized agents invoked by workflows
        enforce_workflow_for_session = False

        # Create session for workflow execution
        session = ClaudeInteractiveSession(
            workspace,
            model,
            enforce_workflow=enforce_workflow_for_session,
            usage_tracker=self.usage_tracker,
        )
        session.task_id = task_id
        self.active_sessions[task_id] = session

        try:
            # Build simple task description with context if provided
            task_parts = []

            if context:
                task_parts.append(context)
            if bot_repo_path:
                task_parts.append(f"Bot codebase: {bot_repo_path}")
            task_parts.append(description)

            simple_task = "\n\n".join(task_parts)

            # Delegate to orchestrator
            workflow_name = "orchestrator"

            # Start session with simple task prompt
            if not await session.start(task_id, prompt=simple_task):
                return False, "Failed to start Claude session", None, None

            # Call callback with PID immediately after process starts
            pid = session.process.pid if session.process else None
            if pid and pid_callback:
                try:
                    pid_callback(pid)
                except Exception as e:
                    logger.error(f"Error in PID callback: {e}", exc_info=True)

            logger.info(f"Task {task_id}: {simple_task[:100]}...")

            # Update task status immediately with workflow name so dashboard shows it
            logger.debug(
                f"Task {task_id}: About to record workflow assignment. usage_tracker={self.usage_tracker}, workflow={workflow_name}"
            )
            if self.usage_tracker:
                await self.usage_tracker.record_workflow_assignment(task_id, workflow_name)
            else:
                logger.warning(f"Task {task_id}: usage_tracker is None, cannot record workflow assignment!")

            # With -p flag, process executes immediately with prompt
            # Stream output and wait for completion
            response = await session.wait_for_completion(progress_callback=progress_callback)

            # Cleanup
            await session.terminate()

            # Check for empty or invalid response
            if not response:
                error_msg = "Claude produced no output. The task may have failed silently or timed out."
                logger.error(f"Task {task_id}: {error_msg}", exc_info=True)
                if self.usage_tracker:
                    self.usage_tracker.record_status_change(task_id, "failed", error_msg)
                    # Update task status in database
                    await self.usage_tracker.db.update_task(task_id, status="failed", error=error_msg)
                return False, error_msg, pid, workflow_name

            # Check if response is essentially empty (just whitespace or minimal content)
            if len(response.strip()) < 10:
                error_msg = f"Claude produced minimal output ({len(response)} chars): {response[:100]}"
                logger.warning(f"Task {task_id}: {error_msg}")
                if self.usage_tracker:
                    self.usage_tracker.record_status_change(task_id, "failed", "Minimal/empty output")
                    # Update task status in database
                    await self.usage_tracker.db.update_task(task_id, status="failed", error=error_msg)
                return False, error_msg, pid, workflow_name

            # Workflow handles its own enforcement, commits, and QA
            # Record completion
            if self.usage_tracker:
                self.usage_tracker.record_status_change(task_id, "completed", "Task completed successfully")
                # Update task status in database
                await self.usage_tracker.db.update_task(task_id, status="completed", result=response[:500])

            return True, response, pid, workflow_name

        except Exception as e:
            logger.error(f"Task execution error: {e}", exc_info=True)

            # Record failure
            if self.usage_tracker:
                error_msg = f"Task execution error: {str(e)}"
                self.usage_tracker.record_status_change(task_id, "failed", error_msg)
                # Update task status in database
                await self.usage_tracker.db.update_task(task_id, status="failed", error=error_msg)

            await session.terminate()
            return False, f"Error: {str(e)}", None, None

        finally:
            # Cleanup session
            if task_id in self.active_sessions:
                del self.active_sessions[task_id]

    async def terminate_session(self, task_id: str) -> bool:
        """
        Gracefully terminate a specific running session
        
        Args:
            task_id: ID of the task to terminate
            
        Returns:
            True if session was found and terminated, False otherwise
        """
        if task_id not in self.active_sessions:
            logger.warning(f"Task {task_id} not found in active sessions")
            return False
        
        session = self.active_sessions[task_id]
        await session.terminate()
        
        # Record stop event
        if self.usage_tracker:
            self.usage_tracker.record_status_change(
                task_id,
                "stopped",
                "Task stopped by user"
            )
            await self.usage_tracker.db.update_task(
                task_id,
                status="stopped",
                error="Stopped by user request"
            )
        
        # Remove from active sessions
        del self.active_sessions[task_id]
        logger.info(f"Task {task_id} terminated by user request")
        return True

    async def terminate_all(self):
        """Terminate all active sessions"""
        for session in self.active_sessions.values():
            await session.terminate()
        self.active_sessions.clear()
